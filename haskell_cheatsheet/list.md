Разбира се! Ето един **cheatsheet** с полезните функции и концепции, които може да си ползваш при решаването на задачите, които обсъдихме:

---

### **1. Основни функции за списъци**

- **head :: [a] -> a**  
  Връща първия елемент на списъка.
  
- **tail :: [a] -> [a]**  
  Връща всички елементи на списъка освен първия.
  
- **null :: [a] -> Bool**  
  Връща `True`, ако списъкът е празен, иначе `False`.
  
- **length :: [a] -> Int**  
  Връща дължината на списъка.
  
- **take :: Int -> [a] -> [a]**  
  Връща първите n елемента на списъка.
  
- **drop :: Int -> [a] -> [a]**  
  Премахва първите n елемента на списъка.
  
- **reverse :: [a] -> [a]**  
  Обръща реда на елементите в списъка.
  
- **map :: (a -> b) -> [a] -> [b]**  
  Преобразува всеки елемент на списъка според функцията.
  
- **filter :: (a -> Bool) -> [a] -> [a]**  
  Пр филтрира елементите на списъка по условие.
  
- **foldr :: (a -> b -> b) -> b -> [a] -> b**  
  Рекурсивно преминава през списъка от дясно на ляво, като прилага функцията `a -> b -> b`.

- **foldl :: (b -> a -> b) -> b -> [a] -> b**  
  Рекурсивно преминава през списъка от ляво на дясно, като прилага функцията `b -> a -> b`.

- **zip :: [a] -> [b] -> [(a, b)]**  
  Комбинира два списъка, като създава двойки от съответни елементи.

- **zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]**  
  Прилага функция към съответни елементи от два списъка.

---

### **2. Основни математически операции**

- **mod :: Int -> Int -> Int**  
  Операция за вземане на остатък при деление.

- **div :: Int -> Int -> Int**  
  Операция за целочислено деление.

- **(+), (-), (*), (/)**  
  Основни аритметични операции.

---

### **3. Функции с вътрешно състояние (Closures)**

- **let**  
  Създава променливи вътре в функции. Пример:
  ```haskell
  let counter = 0 in counter + 1
  ```
  
- **define a closure**  
  Пример на closure, който съхранява вътрешно състояние:
  ```haskell
  createCounter :: Int -> (Int -> Int)
  createCounter start = let counter n = start + n
                        in counter
  ```

---

### **4. Стандартни функции за форматиране на низове**

- **show :: Show a => a -> String**  
  Преобразува стойността в низ.

- **read :: Read a => String -> a**  
  Преобразува низ в стойност от даден тип.
  
- **++ :: [a] -> [a] -> [a]**  
  Конкатенира два списъка.

---

### **5. Допълнителни функции за обработка на списъци и масиви**

- **nub :: Eq a => [a] -> [a]**  
  Премахва повтарящите се елементи от списъка (ако елементи са сравними по равно).

- **concat :: [[a]] -> [a]**  
  Обединява списък от списъци в един списък.

- **takeWhile :: (a -> Bool) -> [a] -> [a]**  
  Връща началната част от списъка, докато условието е вярно.

- **dropWhile :: (a -> Bool) -> [a] -> [a]**  
  Премахва началната част от списъка, докато условието е вярно.

---

### **6. Структури за контролиран достъп**

- **maybe :: b -> (a -> b) -> Maybe a -> b**  
  Прилага функция върху стойност в `Maybe`, ако тя е `Just`, иначе връща дефинирана стойност.

- **Just** и **Nothing**  
  Структури за работа с опционални стойности.

---

### **7. Функции за генериране на изрази**

- **foldl / foldr**  
  Използвайте за създаване на изрази чрез натрупване на елементи.

Пример за генериране на математически израз:
```haskell
generateExpression :: [Int] -> String
generateExpression = foldl (\acc x -> "(" ++ acc ++ "+" ++ show x ++ ")") "1"
```

---

Това е основен cheatsheet, който покрива функциите и концепциите, използвани в задачите. Ако имаш конкретни въпроси относно някоя от тях, не се колебай да попиташ!